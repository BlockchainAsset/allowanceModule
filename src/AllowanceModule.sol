// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity 0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @title Enum - Collection of enums
/// @author Richard Meissner - <richard@gnosis.pm>
contract IEnum {
    enum Operation {
        Call,
        DelegateCall
    }
}

interface ISafe {
    /// @dev Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)
    /// @param to Destination address of module transaction.
    /// @param value Ether value of module transaction.
    /// @param data Data payload of module transaction.
    /// @param operation Operation type of module transaction.
    /// @return success Boolean flag indicating if the call succeeded.
    function execTransactionFromModule(address to, uint256 value, bytes memory data, IEnum.Operation operation)
        external
        returns (bool success);

    /// @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.
    /// @param dataHash Hash of the data (could be either a message hash or transaction hash)
    /// @param data That should be signed (this is passed to an external validator contract)
    /// @param signatures Signature data that should be verified.
    ///                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.
    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures) external view;
}

/// @title AllowanceModule - Execute transactions via the Safe contract with an alternative access scheme.
/// @author Shebin John (Future Solidity Engineer, Safe Wallet)
/// @author Shebin John - <admin@remedcu.com>
contract AllowanceModule {
    string public constant NAME = "AllowanceModule";
    string public constant VERSION = "0.1.0";

    bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH =
        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;
    // keccak256(
    //     "EIP712Domain(uint256 chainId,address verifyingContract)"
    // );

    bytes32 public constant ALLOWANCE_MODULE_TYPEHASH =
        0x9c2a13446babbd893257bddb8625925562e042a80979eb5328096f0ca00a2a36;
    // keccak256(
    //     "AllowanceModule(address safe,address token,address beneficiary,uint256 amount,uint256 expiry,uint256 nonce)"
    // );

    // Specific Safe Centric.
    ISafe public immutable safe;
    // Specific Token Centric.
    IERC20 public immutable token;
    // Signature Nonce to avoid signature replay.
    uint256 public sigNonce;

    // Events
    event safeAndTokenInitialized(address _initiator, address indexed _safe, address indexed _token);
    event allowanceExecuted(
        address _initiator, address indexed _safe, address indexed _token, address indexed _beneficiary, uint256 _amount
    );

    /// @dev A constructor to setup the safe address and the token address
    constructor(address _safe, address _token) {
        require(_safe != address(0), "Zero address for Safe");
        require(_token != address(0), "Zero address for Token");
        safe = ISafe(_safe);
        token = IERC20(_token);
        sigNonce = 1; // To start with non zero number. Just a precaution.
        emit safeAndTokenInitialized(msg.sender, _safe, _token);
    }

    /// @dev Executes the token transfer based on the parameters passed if signature is valid.
    /// @param _beneficiary Address that should receive the tokens.
    /// @param _amount Amount that will be transferred.
    /// @param _signatures Signature generated by the owners of the Safe Wallet to authorize the transfer.
    /// @param _expiry Timestamp after which the signature will expire.
    function executeAllowance(address _beneficiary, uint256 _amount, bytes memory _signatures, uint256 _expiry)
        public
    {
        require(_expiry > block.timestamp, "Signature Expired");
        require(_amount > 0, "Zero Amount");

        uint256 currentNonce = sigNonce;

        // nonce is taken from the Allowance Module state.
        (bytes32 transferHash, bytes memory transferHashData) =
            generateTransferDataAndHash(_beneficiary, _amount, _expiry, currentNonce);

        // Perform external interactions to check signatures through the safe wallet.
        checkSignature(transferHash, transferHashData, _signatures);

        // Update nonce.
        sigNonce = currentNonce + 1;

        // Transfer token.
        transfer(_beneficiary, _amount);

        emit allowanceExecuted(msg.sender, address(safe), address(token), _beneficiary, _amount);
    }

    /// @dev Created a function to inherit this module and extend the signature checking using this function.
    function checkSignature(bytes32 transferHash, bytes memory transferHashData, bytes memory signatures)
        private
        view
    {
        safe.checkSignatures(transferHash, transferHashData, signatures);
    }

    function transfer(address beneficiary, uint256 amount) private {
        bytes memory data = abi.encodeWithSignature("transfer(address,uint256)", beneficiary, amount);
        require(
            safe.execTransactionFromModule(address(token), 0, data, IEnum.Operation.Call),
            "Could not execute token transfer"
        );
    }

    /// @dev Returns the chain id used by this contract.
    function getChainId() public view returns (uint256) {
        uint256 id;
        // solium-disable-next-line security/no-inline-assembly
        assembly {
            id := chainid()
        }
        return id;
    }

    /// @dev Generates the data for the transfer hash (required for signing)
    /// @param _beneficiary Address that should receive the tokens.
    /// @param _amount Amount that will be transferred.
    /// @param _expiry Timestamp after which the signature will expire.
    /// @param _nonce The nonce of this module to avoid signature replay.
    /// @return dataHash Hash of the data generated, data Data generated using the required content.
    function generateTransferDataAndHash(address _beneficiary, uint256 _amount, uint256 _expiry, uint256 _nonce)
        public
        view
        returns (bytes32 dataHash, bytes memory data)
    {
        uint256 chainId = getChainId();
        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, chainId, this));
        bytes32 transferHash =
            keccak256(abi.encode(ALLOWANCE_MODULE_TYPEHASH, safe, token, _beneficiary, _amount, _expiry, _nonce));
        data = abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator, transferHash);
        dataHash = keccak256(data);
    }
}
